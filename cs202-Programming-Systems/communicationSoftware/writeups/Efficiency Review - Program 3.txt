Brooke Czerwinski
CS202
Project 3 - Analysis Writeup

I believe my classes were effective for this program. The structure of my communication and device classes and their derived classes were very much OOP, using a base class and derived classes combined with dynamic binding to allow simple communication pointers to stand in for both texts and calls as well as device pointers which stood for each of the different types of devices that could be used.

However, there are some places where I use getters and setters due to a scope issue. The contact list must contain contacts who have lists of devices, and devices handle communications. Therefore, contacts needed to have access to devices and devices needed to have access to communications. I wasn't able to find a way to allow for this that wouldn't create a circular dependency, though I suspect that if I started by defining base classes first and leaned even more heavily on dynamic binding I could have done it. So, instead, the text and connection (call) classes must be given the phone numbers and names of both the sender and recipient.

However, if I were to redo this application with the ability to tweak the requirements, I would make it a bit like real-life and use a device-centric approach. In a redesign like this, each device would have the phone number of another device in its list, which would allow me to use a table lookup very easily (which would be very efficient). A contact list would simply be a list of phone numbers with a name label, and this would allow me to simply work on the contact list structure first, so it can be the most-indirect base class. Then it would be easy for the communication class itself to be in charge of accessing the contact class and choosing a recipient.

This setup, while slightly spaghetti'd in the very child-most class, is actually very efficient. I used a BST for the contacts and this allows a user to add contacts in any order while still getting a generally good efficiency (at it's best when it is balanced it could get an O(logN) efficiency). But, this is because my program relies on users entering their information manually. In an automated situation a BST would probably be one of the worst approaches, as the data would probably be loaded into the data structure alphabetically, leading to an O(N) efficiency as it essentially turns into a linear linked list.

Overall, one of my favorite take-aways from this program, however, was being able to do the comparisons throughout the BST using the operator overloading that I'd implemented.  Understanding how operator overloading worked with inheritance allowed me to implement the operators in one of the base classes (Contact) and (because ContactVertex inherits from Contact) use the evaluation operators on the vertices within the tree.  That was one of the best uses I've seen for operator overloading (besides the assignment operator overloading!) because it made the code for the evaluation of pathing through the tree much more readable.
